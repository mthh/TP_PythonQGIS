Correction - Exercice 5 : Manipulation de couches vecteurs et géotraitements
============================================================================

.. figure:: ../img/ex6_intro.png
  :width: 40%
  :align: center
  :figwidth: 98%

- En premier lieu :
   ::

     furon = QgsProject.instance().mapLayersByName("Canal_Furon")[0]
     communes = QgsProject.instance().mapLayersByName("COMMUNE")[0]

     ft_furon = list(furon.getFeatures())[0]
     geom_furon = ft_furon.geometry()


- **Q1. Quel est le type de l'objet** ``geom_furon`` **?**
   ::

     print(type(geom_furon))
     # Il s'agit d'un objet de type* ``QgsGeometry``.


- **Q2**.Étant-donné les deux couches d'informations dont on dispose, **quel prédicat
  spatial peut-on utiliser** pour répondre à la question suivante : **Quelle sont les communes traversées par le Canal du Furon ?**

     *On peut utiliser le prédicat spatial* **intersects**.


- **Q3. Comment ce problème pourrait-il être formulé d'un point de vue algorithmique ?**

     Pour chaque entité **FT** de la couche *communes* :

      - Si la geometrie de **FT** intersecte la géometrie du cours d'eau :

        - Ajout du nom de **FT** à une liste.


- **Q4. Créer une liste qui contient le nom des communes traversées par le canal du Furon.**
  ::

    result_q4 = []
    for ft in communes.getFeatures():
        if ft.geometry().intersects(geom_furon):
            result_q4.append(ft['NOM_COM'])

    print('Les communes traversees par le Furon sont : {}.'
          .format(', '.join(result_q4)))

  Le code doit afficher : "*Les communes traversees par le Furon sont : Engins, Noyarey, Sassenage, Lans-en-Vercors.*", il y avait donc **4** communes à trouver.

- Les objets ``QgsGeometry`` disposent d'une méthode buffer qui retourne une nouvelle ``QgsGeometry``.
  On peut créer une zone tampon de 250m autour du cours d'eau de la manière suivante :
  ::

    geom_buffer = geom_furon.buffer(250., 8)


- **Q5. Quelle type de géométrie est obtenu en résultat ? Écrivez l'instruction qui permet d'afficher cette information.**
  ::

    print(QgsWKBTypes.displayString(int(geom_buffer.wkbType())))
    # Il s'agit d'une géométrie de type **Polygon**.



- **Q6. Créer une nouvelle liste contenant le nom des communes qui croisent cette zone tampon. Combien sont-elles ?**
  ::

    # La zone tampon :
    geom_buffer = geom_furon.buffer(250., 8)
    # Une liste vide pour les résultats :
    result_q6 = []

    for ft in communes.getFeatures():
        if ft.geometry().intersects(geom_buffer):
            result_q6.append(ft['NOM_COM'])

    print("Les communes traversees par le buffer de 250m créé autour du Furon sont : {}"
          .format(', '.join(result_q6)))


  Le code doit afficher : "*Les communes traversees par le buffer de 250m créé autour du Furon sont : Engins, Noyarey, Saint-Égrève, Sassenage, Saint-Nizier-du-Moucherotte, Lans-en-Vercors.*", il y avait donc **6** communes à trouver.

- **Q7. Quelles étapes peuvent-être mises en oeuvres pour afficher la zone tampon sur la carte ? Écrivez le code nécessaire créer une nouvelle couche contenant cette zone tampon et pour l'ajouter sur la carte.**
  ::

    # Nouvelle couche (en mémoire) de polygones et son fournisseur de données
    layer = QgsVectorLayer('Polygon?crs=EPSG:2154', 'ZoneTamponFuron' , 'memory')
    pr = layer.dataProvider()

    # Spécification d'un champ d'identifiant
    pr.addAttributes([
        QgsField("ID",  QVariant.Int),
    ])
    layer.updateFields()

    # Création d'une entité pour acceuillir la zone tampon
    feat = QgsFeature()
    # `geom_buffer` est de type QgsGeometry, on peut l'utiliser
    # pour définir la géométrie de cette entité
    feat.setGeometry(geom_buffer)
    # L'id 0 est attribué à cette entité
    feat.setAttributes([0])
    ok = pr.addFeature(feat)
    if ok:
        # Mise à jour de l'étendue de la couche
        layer.updateExtents()

        # Ajout de la couche à la carte
        QgsProject.instance().addMapLayer(layer)
    else:
        # Peut se produire si le nombre ou le type d'attribut ne correspondent
        # pas à ceux attendus pour cette couche
        print("Erreur lors de la création de l'entité !")



- **Q8. En utilisant les éléments vus précédemment, la documentation PyQgis ainsi que les ressources présentes sur le Web :**

  * **1) Créer une nouvelle sélection sur la couche des communes : celles qui intersectent la couche de la zone tampon créée dans la question précédente** *(les entités sélectionnées doivent s'afficher en jaune sur la carte)*

    Pour créer une nouvelle sélection, il faut utiliser la méthode ``selectByIds`` des objets ``QgsVectorLayer``. On va réutiliser la liste crée lors de la question 6
    pour filter les entités de la couche "communes" et récupérer leurs ids :
    ::

      # Une liste qui va contenir les ids des
      # entités à sélectionner
      to_be_selected = [ft.id() for ft in communes.getFeatures() if ft['NOM_COM'] in result_q6]

      # On effectue la sélection
      # à partir des ids précédemment récupérés
      communes.selectByIds(to_be_selected)


  * **2) Sauvegarder uniquement les entités sélectionnés dans une nouvelle couche au format Shapefile.**
    ::

      QgsVectorFileWriter.writeAsVectorFormat(
          communes, # La couche à laquelle on applique cette fonction
          '/home/mthh/Bureau/comm.shp', # Le chemin auquel l'enregistrer
          "utf-8", # L'encodage souhaité
          communes.crs(), # Le système de coordonnées de référence
          "ESRI Shapefile", # Le format de sortie
          onlySelected=True, # Pour n'enregister que les entités sélectionnées
      )
