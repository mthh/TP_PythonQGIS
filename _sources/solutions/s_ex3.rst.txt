Exercice 3 : Géométries et calcul de champ - correction
=======================================================


**Exemple de script permettant de répondre à la question :**

.. container:: spoiler blq

  Solution :

  ::

     from qgis.utils import iface
     from PyQt5.QtCore import QVariant

     # Nom des champs à utiliser :
     _NAME_FIELD = 'NAME'
     _SUM_FIELD = 'POP_EST'

     # Nom des champs à créer
     _NEW_NEIGHBORS_FIELD = 'NEIGHBORS'
     _NEW_SUM_FIELD = 'SUM'

     layer = iface.activeLayer()

     # Création des deux nouveaux champs après avoir activé le mode édition
     layer.startEditing()
     layer.dataProvider().addAttributes(
             [QgsField(_NEW_NEIGHBORS_FIELD, QVariant.String),
              QgsField(_NEW_SUM_FIELD, QVariant.Int)])
     layer.updateFields()

     # Creation d'un dictionnaire contenant nos entités
     # (cela va permettre d'avoir un mappage rapide entre un id et l'entité
     # correspondante, et également de parcourir plusieurs fois la liste
     # des entités sans appeler à nouveau la méthode `getFeatures`
     feature_dict = {f.id(): f for f in layer.getFeatures()}

     # Construction d'un index spatial :
     index = QgsSpatialIndex()
     for f in feature_dict.values():
         index.insertFeature(f)

     # Parcours de l'ensemble de nos entités :
     for f in feature_dict.values():
         # print('Calcul en cours pour {}'.format(f[_NAME_FIELD]))
         geom = f.geometry()
         # Recherche des entités qui intersectent la bbox de l'entité courrante
         # L'utilisation d'un index spatial permet à ce moment de n'itérer que
         # sur les entités qui intersectent sa bbox et non pas sur l'ensemble
         # des entités.
         intersecting_ids = index.intersects(geom.boundingBox())
         # Pour stocker la liste des voisins :
         neighbors = []
         neighbors_sum = 0
         for intersecting_id in intersecting_ids:
             # Récupération de l'entité dans le dictionnaire
             intersecting_f = feature_dict[intersecting_id]
             # Ici on considère qu'une entité est voisine si elle touche ou intersecte
             # l'entité en cours. Nous utilisons donc le prédicat spatial
             # 'disjoint' pour vérifier cela:
             if (f != intersecting_f and
                 not intersecting_f.geometry().disjoint(geom)):
                 neighbors.append(intersecting_f[_NAME_FIELD])
                 neighbors_sum += intersecting_f[_SUM_FIELD]
         f[_NEW_NEIGHBORS_FIELD] = ','.join(neighbors)
         f[_NEW_SUM_FIELD] = neighbors_sum
         # Mise à jour de l'entité modifiée :
         layer.updateFeature(f)

     layer.commitChanges()
