Exercice 5 : Ouverture d'un raster et enrichissement d'une couche vecteur
=========================================================================

.. figure:: img/ex5_mnt_color.png
  :width: 40%
  :align: center
  :figwidth: 98%


Objectif
--------

L'objectif de cet exercice est de cr√©er le profil longitudinal d'un cours d'eau.

Cette op√©ration n√©cessite de disposer de points √† distance r√©guli√®re le long du cours d'eau.
Une valeur d'altitude va ensuite √™tre r√©cup√©r√©e √† partir d'un mod√®le num√©rique de terrain.

.. figure:: img/ex5_matplotlib.png
  :width: 40%
  :align: center
  :figwidth: 98%


Donn√©es
-------

| ‚Ä¢ Trac√© du Canal du Furon ``Canal_Furon.shp`` (Ligne - Source : IGN [#f1]_) ‚ûú `T√©l√©chargement <https://mthh.github.io/TP_PythonQGIS/_static/CanalFuron.zip>`_
| ‚Ä¢ Mod√®le Num√©rique de terrain ``DEM_N245E395_l93.tif`` (Raster float 32bits - Source : EAA [#f2]_) ‚ûú `T√©l√©chargement <https://mthh.github.io/TP_PythonQGIS/_static/Mnt.zip>`_

Les deux jeux de donn√©es utilisent la projection Lambert-93 (EPSG:2154).

Proc√©dure
---------

- Ouvrir QGIS.

- Cr√©er un nouveau projet.

- D√©compresser les deux archives ``zip`` qui ont √©t√© t√©l√©charg√©es et ajouter les couches ``Canal_Furon.shp`` et ``DEM_N245E395_l93.tif``.

- Ouvrir la console Python.

- Obtenir la r√©f√©rence de chacune de nos couches :

  ::

    line_lyr = QgsProject.instance().mapLayersByName("Canal_Furon")[0]
    dem = QgsProject.instance().mapLayersByName("DEM_N245E395_l93")[0]

- Disposer des points √† √©gale distance le long du trac√© du cours d'eau :

  ::

    # Quelle est la longueur du cours d'eau ?
    ft = list(line_lyr.getFeatures())[0]
    geom = ft.geometry()
    length = geom.length() # En unit√©s de la carte (ici en m.)

    # Combien de points ?
    nb_pts = 50

    # Distance entre points successifs
    step = length / nb_pts

    # Cr√©ation d'un it√©rateur appropri√© et ajout des points cr√©√©s √† une liste :
    result = []
    for dist in range(0, int(length), int(step)):
        # Le resultat va √™tre de type `QgsGeometry`
        interp = geom.interpolate(dist)
        # Convertit la g√©om√©trie en `QgsPointXY` et l'ajoute au r√©sultat
        result.append(interp.asPoint())


- R√©cup√©rer la valeur de la (ou des) bande(s) raster √† une coordonn√©e donn√©e :

  ::

    dem_pr = dem.dataProvider()
    pt = QgsPointXY(925189, 6473673)
    res = dem_pr.identify(pt, 1)
    if res.isValid():
        _values = res.results() # Retourne un dictionnaire
        # Affiche la valeur pour la premi√®re bande
        print(_values[1])
        # Mieux formatt√©... :
        print("Le point ({}, {}) est situ√© √† environ {:.2f}m d'altitude"
            .format(pt.x(), pt.y(), _values[1]))


- **"Putting it all together"**

  1. Vous disposez des briques essentielles pour cr√©er un objet python de type ``list``,
  contenant, pour une cinquantaine de points r√©partis √† √©gale distance le long du cours d'eau,
  **la distance √† la source** et **l'altitude** de chacun d'entre eux, par exemple sous la forme
  d'un ``tuple`` de 2 √©l√©ments *(les coordonn√©es pr√©cises de chaque
  point ne nous int√©ressent ici que pour connaitre son altitude)*. Ces deux informations,
  distance √† la source et altitude, seront par la suite utilis√©es, respectivement en abcisses
  et en ordonn√©es, pour tracer le profil du cours d'eau.

  2. Lisez le tutoriel `https://futurestud.io/tutorials/matplotlib-simple-line-plots <https://futurestud.io/tutorials/matplotlib-simple-line-plots>`_
  et essayez de mobiliser ces nouvelles notions pour utiliser la liste obtenue √† l'√©tape (1)
  afin d'obtenir le r√©sultat suivant :


  .. figure:: img/ex5_matplotlib.png
    :width: 40%
    :align: center
    :figwidth: 98%


- **Variante : utiliser ces points pour cr√©er une couche de point 3D**
  Dans cet exercice et contrairement √† l'exemple pr√©c√©dent, les coordonn√©es de chaque nouveau point
  nous int√©ressent : elles vont √™tre enrichie de l'altitude du point.
  Ces points devront √™tre ajout√©s √† **une nouvelle couche en m√©moire** qui aura
  pr√©c√©demment √©t√© cr√©√©e avec **deux champs attributaires**,
  l'un pour l'identifiant du point (de type *entier*) et l'autre pour
  la distance √† la source (de type *double flottant*).


- **D√©j√† termin√© !?**
  Prenez le temps de consulter le sujet propos√© lors du contr√¥le des connaissances de l'ann√©e derni√®re (`Sujet Mars 2019 <_static/PythonQGIS_2019.pdf>`_ *(avec QGIS 2)*) avant de passer √† l'exercice suivant !


.. note::
  L'API expos√©e par PyQgis n'est pas toujours tr√®s "pythonique".
  Certaines fonctions vues au cours de cet exercice ne vont pas g√©n√©rer une ``Exception``
  comme c'est la convention en Python mais vont retourner une valeur bool√©enne qu'il
  faudra lire pour s'assurer de la bonne ex√©cution de la fonction en question.

  .. code-block:: python
     :emphasize-lines: 3,4,10,11

      for ix, dist in enumerate(range(0, int(length), int(step))):
          pt = geom.interpolate(dist).asPoint()
          alt, valid = data_pr.sample(pt, 1)
          if valid:
              new_pt = QgsPoint(pt.x(), pt.y(), alt)
              feat = QgsFeature()
              feat.setGeometry(QgsGeometry(new_pt))
              feat.setAttributes([ix, dist])
              ok = pr.addFeature(feat)
              if not ok:
                  print("Erreur lors de la cr√©ation de l'entit√© {}".format(ix))
          else:
              print(
                "Erreur lors de la r√©cup√©ration de l'altitude pour l'entit√© {}"
                .format(ix)")

.. raw:: html

   <hr width="100%" size="18">
   <p class="align-center"><strong>üí° <a href="solutions/s_ex5.html">Solution de l'exercice 5</a></strong></p>

.. rubric:: Footnotes

.. [#f1] Institut national de l'information g√©ographique et foresti√®re : http://professionnels.ign.fr/bdtopo. Donn√©es t√©l√©charg√©es le 28/02/2019.
.. [#f2] European Environment Agency : https://www.eea.europa.eu/data-and-maps/data/copernicus-land-monitoring-service-eu-dem. Donn√©es t√©l√©charg√©es le 28/02/2019.
