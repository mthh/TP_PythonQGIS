Cheatsheet
==========


  Voir également la `cheatsheet dans le documentation officielle PyQgis <https://docs.qgis.org/3.4/en/docs/pyqgis_developer_cookbook/cheat_sheet.html>`_.


Canvas
^^^^^^

**Accéder au canvas**
::

  canvas = iface.mapCanvas()


Manipulation des couches de données
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Lister les couches actives dans l'interface**
::

  iface.mapCanvas().layers() # Retourne une liste


**Lister les couches chargées et leurs ids**
::

  QgsProject.instance().mapLayers() # Retourne un dictionnaire id -> layer


**Trouver une couche en utilisant son nom**
::

  # Pour obtenir la couche dont le nom est 'name'
  layer = QgsProject.instance().mapLayersByName("name")[0]
  print(layer.name()) # Doit donc afficher.. 'name'


**Définir la couche active**
::

  iface.setActiveLayer(layer)


**Enlever toutes les couches**
::

  QgsProject.instance().clear()


**Charger un fichier de style (Symbologie, étiquettes, etc.) au format .qml**
::

  layer.loadNamedStyle("path/to/file.qml")

**Renommer une couche**
::

  layer.setName("roads")

**Obtenir le système de coordonnées de référence (CRS)**
::

  for layer in QgsProject.instance().mapLayers().values():
      crs = layer.crs().authid()
      layer.setName(layer.name() + ' (' + crs + ')')


**Charger toutes les couches d'un GeoPackage**
::

  filename = "sample.gpkg"
  layer = QgsVectorLayer(filename, "test", "ogr")
  subLayers = layer.dataProvider().subLayers()

  for subLayer in subLayers:
      name = subLayer.split('!!::!!')[1]
      uri = "%s|layername=%s" % (filename, name,)
      # Création de la couche
      sub_vlayer = QgsVectorLayer(uri, name, 'ogr')
      # Ajout au projet
      QgsProject.instance().addMapLayer(sub_vlayer)


**Réorganiser les couches en utilisant ``QgsLayerTree``**
::

  # 'layer' is the layer to be moved to at position 0
  # in the layer tree :
  tree = QgsProject.instance().layerTreeRoot()
  for ch in tree.children():
      if ch.name() == layer.name():
          _ch = ch.clone()
          tree.insertChildNode(0, _ch)
          tree.removeChildNode(ch)


Couches vecteurs
^^^^^^^^^^^^^^^^

**Ajout d'une couche vecteur**
::

  layer = iface.addVectorLayer("input.shp", "name", "ogr")
  if not layer:
      print("Layer failed to load!")


**Affichage du type d'une couche vecteur**
::

  print(QgsWkbTypes.displayString(layer.wkbType()))
  # is layer a LineString ?
  is_line = layer.wkbType() in (QgsWkbTypes.LineString, QgsWkbTypes.MultiLineString)


**Modifier une géométrie**
::

  # la variable `feat` est ici un objet de type `QgsFeature`
  geom = feat.geometry()
  geom.translate(100, 100)
  feat.setGeometry(geom)


**Ajouter un nouvel enregistrement - Ouverture d'un formulaire interactif**
::

  iface.openFeatureForm(iface.activeLayer(), QgsFeature(), False)


**Changer l'opacité (la transparence) globale d'une couche**
::

  layer.setOpacity(0.5)


Couches raster
^^^^^^^^^^^^^^^^

**Ajout d'une couche raster**
::

  layer = iface.addRasterLayer("/path/to/raster/file.tif", "name")
  if not layer:
      print("Raster layer failed to load!")

**Obtenir le nombre de bandes**
::

  # layer is a QgsRasterLayer
  layer.bandCount()

**Obtenir la valeur qui correspond à des coordonnées sur une bande**
::

  pt = QgsPoint(48.3, 2.35)
  band = 1
  # layer is a QgsRasterLayer
  value, valid = layer.dataProvider().sample(pt, band)


**Obtenir la valeur qui correspond à des coordonnées sur l'ensemble des bandes**
::

  pt = QgsPoint(48.3, 2.35)
  # layer is a QgsRasterLayer
  result = layer.dataProvider().identify(pt)
  # 'result' is of type `QgsRasterIdentifyResult`
  if result.isValid():
      print(result.results)


Processing algorithms
^^^^^^^^^^^^^^^^^^^^^

**Obtenir une liste des algo. disponibles**
::

  for alg in QgsApplication.processingRegistry().algorithms():
      print("{}:{} --> {}".format(
          alg.provider().name(), alg.name(), alg.displayName()))


**Obtenir de l'aide sur un algo.**

*L'argument de* ``processing.algorithmHelp`` *est l'identifiant d'un algorithme, de la forme 'provider_name:algo_name'.*

::

  import processing
  provider = 'qgis'
  algo = 'randomselection'
  processing.algorithmHelp("{}:{}".format(provider, algo))


**Exécuter un algo.**

*La fonction* ``processing.run`` *attend toujours deux arguments: une chaine de caractères contenant l'identifiant d'un algorithme et un dictionnaire
contenant les paramètres à utiliser.*

::

  import processing
  algo_name = "qgis:buffer"
  algo_params = {'INPUT': layer, 'DISTANCE': 100, 'OUTPUT': 'TEMPORARY_OUTPUT'}
  processing.run(algo_name, algo_params)
