Exercice 7 : Construction d'un plugin
=====================================

.. figure:: img/ex7_logo_plugin_builder.png
  :align: center
  :figwidth: 98%

Objectif
--------

L'objectif de cet exercice est de créer un premier plugin pour QGIS.

L'outil ``Qt Designer 5`` va être nécessaire pour construire l'interface graphique.

Dans le cas de l'utilisation de Windows, on préférera une installation de QGIS réalisée
avec `OSgeo4W <https://www.qgis.org/fr/site/forusers/download.html#windows>`_ qui donnera
accès à la possibilité d'installer facilement les composants nécessaires au développement
de plugins (tels que les outils ``Qt Designer`` et ``pyuic5``) et d'accéder
à une console système paramétrée correctement pour les utiliser.


Données et outils nécessaires
-----------------------------

| -> **Qt Designer 5** (normallement installé lors d'une nouvelle installation de QGIS).
| -> Plugin QGIS ``Plugin Builder``.
| -> Couche des départements français (``TP_Python_Qgis/data/ex7/departements_2015.shp``) pour vérifier le fonctionnement du plugin.

| -> Le résultat de ce TP est disponible à l'adresse : https://github.com/mthh/TP_PythonQGIS_plugin/ (code, archive du plugin prêt à être installé, etc.).


Mise en situation
-----------------

Pour les besoins d'une structure territoriale qui doit fusionner ses communes,
nous devons développer un plugin proposant à l'utilisateur de **sélectionner
des polygones voisins et de les fusionner**.

Un formulaire sera ouvert pour permettre à l'utilisateur de **saisir les nouveaux
attributs de cette entité** (nom de la commune fusionnée, nouveaux code, etc.)

Une fois ces informations validées, les entités dont sont issues la fusion seront
supprimées de la couche en question.


Procédure
---------

- Démarrer QGIS 3.

- Installer l'extension ``Plugin Builder`` et l'extension ``Plugin Reloader``
  depuis le gestionnaire des extensions (Menu ``Extension > Gestionnaire des extensions``)

.. figure:: img/ex7_extension.png
  :width: 100%
  :align: center
  :figwidth: 98%


.. note::
  L'extension ``Plugin Builder`` va seulement être utilisée lors de la création du plugin.
  Elle permet de créer l'ensemble des fichiers nécessaires au développement d'un plugin
  et va nommer les fichiers et les prototypes de classes et de fichiers d'interface
  au regard du nom et de la description donnée au plugin à créer.


.. note::
  L'extension ``Plugin Reloader`` va permettre de recharger le plugin dans QGIS au cours de son développement.
  Elle permet, en un clic, de charger la dernière version d'un plugin (à partir du répertoire d'installation par défaut des plugins : ~/.qgis2/python/plugins).
  Cette extension est dans la catégorie extension expérimentale, si ce n'est pas déjà fait, il est nécessaire d'autoriser l'installation de ce type
  d'extensions.


.. figure:: img/ex7_extension_exp.png
  :width: 100%
  :align: center
  :figwidth: 98%



- Ouvrir ``Plugin Builder`` (Menu ``Extension > Plugin Builder > Plugin Builder``).

- Saisir les différentes informations demandées :

  Pour respecter les conventions Python :
    - nom de classe en *CamelCase* [#f1]_
    - nom du module en minuscule avec underscore si besoin [#f2]_
  Pour respecter les conventions de publication des plugins QGIS :
    - on évite le mot "plugin" dans la nom du plugin [#f3]_


  .. figure:: img/ex7_builder_fields.png
    :align: center
    :figwidth: 98%


  .. figure:: img/ex7_builder_fields2.png
    :align: center
    :figwidth: 98%

    On choisi le type de template à utiliser pour la fenêtre qui va être créée,
    le nom qui sera utilisé dans le menu de QGIS et le menu dans lequel sera ajouté.


- Les panneaux suivants peuvent être laissés par défaut, à l'exception du dernier où il est
  nécessaire de sélectionner l'emplacement à utiliser pour stocker le code généré pour ce plugin.

  .. figure:: img/ex7_builder_fields3.png
    :align: center
    :figwidth: 98%


- Le développement de ce plugin va se passer en plusieurs étapes.
  Dans un premier temps nous allons éditer le fichier ``.ui`` qui est utilisé par Qt.
  Ces fichiers (au format XML) sont utilisé par Qt / PyQt pour générer du code (au format C++ dans le cas de Qt, en Python dans notre cas avec PyQt),
  soit lors de l'éxécution du programme qui les appelle, soit lors d'une étape préalable de compilation.

- Ouvrir l'outil ``QtDesigner`` (``Démarrer -> Tous les programmes -> OSGeo4W -> QtDesigner pour QGIS X.xx`` sur Windows)
  et charger le fichier ``neighbor_merger_dialog_base.ui`` généré précédemment par ``Plugin Builder``.

  Pour le besoin de notre plugin nous allons avoir besoin d'une liste déroulante
  permettant de sélectionner à quelle couche doit s'appliquer le traitement.
  Ce type d'élément s'apelle ``QComboBox`` dans Qt.

  QGIS est fourni avec différents éléments facilitant le développement de plugin tels qu'une classe ``QgsMapLayerComboBox`` :
  il s'agit d'une sous classe de ``QComboBox`` qui est directement alimentée par la liste des couches chargées dans QGIS.
  Cet objet va également permettre de filter le type de couche à afficher en fonction de leur type de géométrie par exemple;
  nous allons utiliser cette fonctionnalité.


  .. figure:: img/ex7_qtdesigner_combobox.png
    :width: 100%
    :align: center
    :figwidth: 98%


  Une fois cet élément ajouté à la fenêtre, aller dans *l'éditeur de propriété* et changer son nom de ``mMapLayerComboBox`` vers ``targetLayerComboBox``.

  Changer ensuite les filtres relatifs aux couches affichées dans cette liste déroulante afin de n'autoriser que les ``Polygon Layer``.

  .. figure:: img/ex7_qtdesigner_end.png
    :width: 100%
    :align: center
    :figwidth: 98%

  Sauvegarder ce fichier et fermer ``QtDesigner``.

- Les étapes suivantes (écriture du code du plugin, etc.) ne nécessitent pas d'utiliser l'éditeur de code fournit avec Python; il est conseiller d'utiliser un éditeur plus confortable.

  Les principales briques nécessaires pour écrire le code sont les suivantes :

  * Identifier les entités sélectionnées dans la couche demandée par l'utilisateur
    ::

      selected = layer.selectedFeatures()


  * Fusionner les géométries de ces entités en une nouvelle géométrie. Cette opération est généralement appelée une union
    (toutefois il s'agit d'un mot réservé en C++, la méthode a donc été appelée ``combine`` dans QGIS et donc par
    extension dans PyQgis).
    ::

      geoms = [ft.geometry() for ft in selected]
      merged_geom = QgsGeometry(geoms[0])
      for geom in geoms[1:]:
          merged_geom.combine(geom)

  * Créer une nouvelle entité utilisant cette géométrie et ouvrir le formulaire proposant à l'utilisateur de saisir ses attributs.
    /!\ Ne pas oublier que la couche doit être en mode édition (voir exercice 3) au moment de l'ouverture du formulaire,
    comme au moment de l'ajout de la nouvelle entité ou au moment de la suppression des anciennes entités !

    ::

      new_feature = QgsFeature()
      new_feature.setGeometry(merged_geom)
      new_feature.setFields(layer.fields())
      validated = iface.openFeatureForm(layer, new_feature, False)
      layer.dataProvider().addFeature(new_feature)


  * Gérer quelques erreurs possibles : les entités sélectionnées ne sont pas réellement voisines par exemple.


  * Enlever les anciennes entités une fois que la nouvelle a été ajoutée avec succès :

    ::

      for ft in selected:
          layer.deleteFeature(ft.id())

  * On va aussi définir une fonction qui affichera un message d'erreur si nécessaire:
    ::

      def display_error(message):
          iface.messageBar().pushMessage(
              "Erreur", message, level=Qgis.Critical)


  * L'essentiel de la logique peut ainsi être résumée ainsi :

    .. container:: spoiler blq

       Solution :

       ::

          def merge_selected_features(layer):
              # Récupération de la liste des entités (QgsFeature) sélectionnées :
              selected = layer.selectedFeatures()
              if len(selected) < 2:
                  display_error('Le nombre d\'entités sélectionné est insuffisant')
                  return

              # Déselectionne les entités sélectionnés :
              layer.removeSelection()

              # Récupération des géométries (QgsGeometry)
              # des entités sélectionnées :
              geoms = [ft.geometry() for ft in selected]

              # Fusion des entités dans la nouvelle géométrie 'merged_geom' :
              merged_geom = QgsGeometry(geoms[0])
              for geom in geoms[1:]:
                  merged_geom = merged_geom.combine(geom)

              # Création de la nouvelle entité utilisant cette géométrie
              # (il est nécessaire de lui dire les champs à utiliser
              #  avant l'ouverture du formulaire)
              new_feature = QgsFeature()
              new_feature.setGeometry(merged_geom)
              new_feature.setFields(layer.fields())

              # Entre en mode édition :
              layer.startEditing()

              # Ouverture du formulaire relatif à la nouvelle entité :
              valid = iface.openFeatureForm(layer, new_feature, False)
              if not valid:
                  # Sortie du mode édition sans valider d'éventuels changements
                  # et affichage d'un message d'erreur
                  layer.rollBack()
                  display_error('Erreur dans la saisie des attributs')
                  return

              # Ajout de la nouvelle entité :
              valid = layer.dataProvider().addFeature(new_feature)
              if not valid:
                  # Sortie du mode édition sans valider d'éventuels changements
                  # et affichage d'un message d'erreur
                  layer.rollBack()
                  display_error('Erreur lors de l\'ajout de la nouvelle entité')
                  return

              # Suppression des entités dont est issues la fusion :
              for ft in selected:
                  layer.deleteFeature(ft.id())

              # Validation des changements :
              layer.commitChanges()


  * Les étapes suivantes consistent à intégrer cette logique à notre plugin.


  - **Bonus** : on veut vérifier que les poylgones à fusionner sont bien voisins.
    Comment s'y prendre ? Pour deux polygones ? Pour 3, 4 ou un nombre indéterminé ?

    .. container:: spoiler blq

       Solution :

       ::

          def all_touches_one_group(geoms):
              """
              Étant donné une liste de `QgsGeometry` cette fonction retourne un tuple
              dont le premier élément contient une valeur booléene (True / False, en
              fonction de si les géométries se touchent en formant un seul groupe)
              et dont le deuxième élément contient la raison si la réponse est False,
              ou un message vide sinon.
              """
              d = {i: [] for i in range(len(geoms))}
              # Pour chaque géométrie on va créer une liste de
              # ses voisines directes
              for ix1, g1 in enumerate(geoms):
                  for ix2, g2 in enumerate(geoms):
                      if ix1 == ix2: continue
                      if g1.touches(g2):
                          d[ix1].append(ix2)

              # Si au moins une d'entre elles à cette liste de vide,
              # c'est qu'elle n'a aucune voisine
              if any(len(li) == 0 for li in d.values()):
                  return (False, 'Au moins une géométrie est isolée')

              # Pas besoin de continuer les vérifications s'il n'y a que
              # deux géomtries, elles sont bien voisines :
              if len(geoms) == 2:
                  return (True, '')

              # On va regarder si on peut parcourir l'ensemble des géométries
              # en allant de géométrie qui se touche à géométrie qui se touche

              # Un `set` pour garder une trace des polygones parcourus
              seen = set()

              # Une fonction récursive est définie pour parcourir les polygones
              # qui n'ont pas encore été vus
              def go_through(li):
                  for item in li:
                      if not item in seen:
                          seen.add(item)
                          go_through(d[item])

              # On applique cette fonction de manière arbitraire au premier polygone
              start_list = d[0]
              for ix in start_list:
                  go_through(d[ix])

              # On vérifie que le nombre de polygones parcourus est égal au
              # nombre de polygones en entrée, sinon c'est qu'il y a plusieurs
              # groupes distincts de polygones qui se touchent

              if len(seen) != len(geoms):
                  return (False, 'Les géométries sont en plusieurs groupes distincts')

              return (True, '')

- Sur windows ouvrir l'intépréteur de commande fournit à l'installation de QGIS en ouvrant
  ``Démarrer -> Tous les programmes -> OSGeo4W -> OSGeo4W Shell``

- Sur GNU/Linux ou Mac OS X ouvrir la console système habituelle.

- Se rendre dans le dossier précédemment choisit pour enregistrer le code de votre plugin :
  ::

    # Par exemple pour gnu/linux ou mac os x
    cd /home/mthh/code/neighbor_merger

    # Par exemple pour windows
    cd C:\home\matthieu\Desktop\code\neighbor_merger


- Utiliser l'utilitaire ``Make`` pour préparer le code et le déplacer à l'emplacement des plugins QGIS.

  * Pour installer localement le plugin on utilisera la commande  ``make deploy``.

  * Pour créer une archive zippée du plugin on pourra utiliser ``make zip``.

  * Les différentes actions relatives à ces commandes (``zip``, ``deploy``, etc.)
    sont décrite dans le fichier nommé ``Makefile``. C'est dans ce fichier
    qu'il sera nécessaire de préciser si d'autres éléments (données d'exemple,
    images, etc.) doivent être prise en compte lors de l'installation du plugin.


.. rubric:: Footnotes

.. [#f1] https://www.python.org/dev/peps/pep-0008/#id41
.. [#f2] https://www.python.org/dev/peps/pep-0008/#id40
.. [#f3] https://plugins.qgis.org/
