Exercice final / √† faire √† la maison
====================================

.. figure:: img/tp8_0.png
  :width: 40%
  :align: center
  :figwidth: 98%


.. rubric:: \
|

  **‚ö†** *Vous devez envoyer le script permettant de r√©pondre √† l'ensemble des questions* **‚ö†**


Objectif
--------

- D√©couvrir et utiliser les algorithmes de la boite √† outil de g√©otraitement (*processing algorithms*) en Python.

- Combiner plusieurs g√©o-traitements pour r√©pondre √† une question d'analyse spatiale.


Nouvelles notions
-----------------

L'ensemble des **g√©o-traitements** disponibles sous forme de boites de dialogues dans QGIS est √©galement accessible au travers de l'API Python.
C'est √©galement le cas pour les g√©o-traitements propos√©es dans QGIS par les extensions GRASS, SAGA et GDAL.

Contraitement aux manipulations que nous avons effectu√©es auparavant, ces g√©o-traitements prennent en entr√©e une (ou plusieurs) couche(s) et produisent g√©n√©ralement une couche en sortie.
Il s'agit par exemple de traitements tels que :

- Cr√©ation d'une zone tampon

- Cr√©ation de Polygones Voronoi

- Cr√©ation d'une grille au format vecteur

- Rast√©riserisation d'une couche vecteur

- Etc.

En utilisant le code suivant, il est possible de lister l'ensemble des algorithmes disponibles dans QGIS :

::

  for alg in QgsApplication.processingRegistry().algorithms():
      print("{} --> {}".format(alg.id(), alg.displayName()))

Le texte qui s'affiche est de la forme :

::

  ...
  native:centroids --> Centro√Ødes
  native:clip --> Couper
  ...

La partie de gauche d√©signe l'idenfifiant de l'algorithme (``native:centroids`` par exemple)
et celle de droite son intitul√© (``Centro√Ødes`` par exemple) dans la langue utilis√©e par QGIS *(ici le fran√ßais - certains intitul√©s ne sont toutefois pas traduits)*.
Il est ainsi possible d'acc√©der en Python √† l'ensemble des g√©o-traitements de la boite √† outils.

.. figure:: img/tp8_1.png
  :width: 100%
  :align: center
  :figwidth: 98%

L'acc√®s √† ces algorithmes se fait via le module ``processing``.

::

  import processing


**‚ûú La fonction** ``algorithmHelp`` **va permettre d'afficher l'aide d'un algorithme**:

::

  processing.algorithmHelp("native:centroids")


Il est indispensable de lire la documentation d'un algorithme avant de l'utiliser : c'est elle qui indique quels sont les param√®tres requis pour l'utiliser.

  L'aide des diff√©rents g√©o-traitements peut √©galement √™tre affich√©e au format HTML √† partir de la page : https://docs.qgis.org/3.10/en/docs/user_manual/processing_algs/index.html.

::

  Centro√Ødes (native:centroids)

  Cet algorithme cr√©√© un nouvelle couche de type point, ou les points repr√©sentent le barycentre des entit√©s d'une couche d'entr√©e.

  Les attributs associ√©s aux points dans la couche de sortie  sont ceux des points de la couche d'origine.


  ----------------
  Input parameters
  ----------------

  INPUT: Couche source

  	Parameter type:	QgsProcessingParameterFeatureSource

  	Accepted data types:
  		- str: ID de couche
  		- str: nom de couche
  		- str: couche source
  		- QgsProcessingFeatureSourceDefinition
  		- QgsProperty
  		- QgsVectorLayer

  ALL_PARTS: Cr√©er un centro√Øde pour chaque partie

  	Parameter type:	QgsProcessingParameterBoolean

  	Accepted data types:
  		- bool
  		- int
  		- str
  		- QgsProperty

  OUTPUT: Centro√Ødes

  	Parameter type:	QgsProcessingParameterFeatureSink

  	Accepted data types:
  		- str: fichier vecteur de destination, par ex. 'd:/test.shp'
  		- str: 'memory:' pour stocker le r√©sultat dans une couche temporaire en m√©moire
  		- str: using vector provider ID prefix and destination URI, e.g. 'postgres:‚Ä¶' to store result in PostGIS table
  		- QgsProcessingOutputLayerDefinition
  		- QgsProperty

  ----------------
  Outputs
  ----------------

  OUTPUT:  <QgsProcessingOutputVectorLayer>
  	Centro√Ødes

Cette aide nous apprend :

- Que l'algorithme s'utilise avec 3 param√®tres d'entr√©e : ``INPUT``, ``ALL_PARTS`` et ``OUTPUT`` *(nous allons voir comment les utiliser simplement ensuite)*,
- Que le r√©sultat attendu est de type ``QgsProcessingOutputVectorLayer`` : cet objet va nous permettre d'obtenir une couche de type ``QgsVectorLayer`` comme manipul√©e dans les TP pr√©c√©dents si l'√©x√©cution se d√©roule sans probl√®me.

**‚ûú La fonction** ``run`` **va permettre d'√©x√©cuter l'algorithme**.

Son premier argument est l'identifiant de l'algorithme √† √©x√©cuter et son second argument est un dictionnaire Python (objet ``dict``) d√©crivant
les param√®tres de l'algorithme (couche(s) en entr√©es, type de sortie, √©ventuelles options.)

L'exemple suivant utilise une de mes couches (nomm√©e ``park`` dans mon projet QGIS) pour calculer le centroide de chaque entit√©.
Le r√©sultat est stock√© dans une couche temporaire en m√©moire et est ajout√© au projet actuel.

::

  layer = QgsProject.instance().mapLayersByName("park")[0]
  result = processing.run(
      "native:centroids",
      {'INPUT': layer, 'ALL_PARTS': False, 'OUTPUT': 'TEMPORARY_OUTPUT'}
  )
  QgsProject.instance().addMapLayer(result['OUTPUT'])

L'ex√©cution du code pr√©c√©dent correspond ainsi √† l'action suivante dans l'interface de QGIS :

.. figure:: img/tp8_2.png
  :width: 100%
  :align: center
  :figwidth: 98%

Dans l'interface, on retrouve √©galement apr√®s l'√©x√©cution, dans l'onglet ``Journal`` le dictionnaire des **param√®tres en entr√©e**
utilis√© pour ce g√©o-traitement :

.. figure:: img/tp8_3.png
  :width: 100%
  :align: center
  :figwidth: 98%

Puisque l'on obtient une nouvelle couche, il est ainsi possible d'enchainer plusieurs traitements de ce type de mani√®re simple.
Si je cherche √† cr√©er des polygones de Voronoi qui correspondent √† mes parks (cet algorithme n√©cessite une couche de points en entr√©e),
je peux ainsi r√©aliser les traitements suivants :

::

   input_layer = QgsProject.instance().mapLayersByName("park")[0]
   # 1. Calcul des centroides
   result_centroids = processing.run(
     "native:centroids",
     {'INPUT': input_layer, 'ALL_PARTS': False, 'OUTPUT': 'TEMPORARY_OUTPUT'})
   centroid_layer = result_centroids['OUTPUT']
   # 2. Calcul des polygones de voronoi
   # et choix d'un chemin pour enregister le r√©sultat :
   result_voronoi = processing.run(
     "qgis:voronoipolygons",
     {'INPUT': centroid_layer, 'BUFFER': 5, 'OUTPUT': 'TEMPORARY_OUTPUT'})
   # 3. Ajout des polygones de voronoi au projet
   QgsProject.instance().addMapLayer(result_voronoi['OUTPUT'])


.. figure:: img/tp8_4.png
  :width: 100%
  :align: center
  :figwidth: 98%

.. figure:: img/tp8_5.png
  :width: 100%
  :align: center
  :figwidth: 98%

Ici ``result_voronoi['OUTPUT']`` est un objet de type ``QgsVectorLayer`` comme manipul√© dans les TP pr√©c√©dents : il est possible de changer son nom dans l'interface et ceci
est conseill√© afin d'identifier plus facilement vos couches.

::

  result_voronoi['OUTPUT'].setName('voronoi_park')

.. figure:: img/tp8_6.png
  :width: 60%
  :align: center
  :figwidth: 98%

Exercice
--------

Nous souhaitons en savoir plus sur le profil socio-d√©mographique des habitants de Paris en utilisant un d√©coupage original : celui qui peut √™tre obtenus √† partir des stations de m√©tros.

.. figure:: img/tp8_7.png
  :width: 100%
  :align: center
  :figwidth: 98%

En effet nous pourrions vouloir r√©pondre √† plusieurs questions telles que:

- **quels sont les niveaux de revenus √† proximit√© de ma station de m√©tro ?**

- quelles stations de m√©tro sont situ√©es dans les zones les plus dens√©ment peupl√©es ?

- aux alentour de quelles stations sont principalement localis√©es les r√©sidences secondaires ?

.. rubric:: \
|


Nous allons r√©pondre √† la premi√®re de ces questions en utilisant les couches de donn√©es suivantes :

- ``IRIS_MENAGE_PARIS`` : les donn√©es socio-√©conomique disponibles au niveau des `IRIS <https://fr.wikipedia.org/wiki/%C3%8Elots_regroup%C3%A9s_pour_l%27information_statistique>`_ situ√©s √† Paris (les donn√©es proviennent de l'APUR [#f1]_ et ont √©t√© enrichies avec des donn√©es de l'INSEE [#f2]_). Le principal champ qui nous int√©resse dans cette couche est ``RDEC_MED16`` : le revenu m√©dian d√©clar√© par m√©nage.

- ``STATION_METRO_PARIS`` : les stations de m√©tro situ√©es dans Paris (les donn√©es proviennent de l'APUR [#f3]_). Cette couche dispose notamment d'un champ nomm√© ``L_STATION`` : le nom de la station.


.. rubric:: \
|

**0.** T√©l√©charger l'archive zipp√©e qui contient les donn√©es : https://mthh.github.io/TP_PythonQGIS/_static/data_pyqgis.zip

La d√©compresser dans votre espace de travail.

Cr√©er un nouveau projet QGIS utilisant la projection **EPSG:2154 (Lambert 93 / RGF 93)**.

Ajouter les couches ``STATION_METRO_PARIS.shp`` et ``IRIS_MENAGE_PARIS.shp`` et s'assurer qu'elles sont bien dans la m√™me projection que le projet.

.. figure:: img/tp8_8.png
  :width: 100%
  :align: center
  :figwidth: 98%

..

  **‚ö†** *L'ensemble des √©tapes suivantes doit √™tre effectu√© en Python. Une capture d'√©cran vous indique quel est le r√©sultat attendu √† l'issue de chaque √©tape.* **‚ö†**

..

**1.** **Obtenir une r√©f√©rence Python aux couches** ``STATION_METRO_PARIS`` **et** ``IRIS_MENAGE_PARIS``. **Appliquer le style du fichier** ``Style_STATION_METRO_PARIS.qml`` **√† la couche** ``STATION_METRO_PARIS``.

.. figure:: img/tp8_9.png
  :width: 100%
  :align: center
  :figwidth: 98%

**2.** √Ä partir de la couche ``IRIS_MENAGE_PARIS`` et en utilisant l'aglorithme ``native:dissolve``, **cr√©er une couche correspondant √† l'emprise de la ville de Paris**.

**L'ajouter au projet actuel et la renommer** ``COMMUNE_PARIS``.

.. figure:: img/tp8_10.png
  :width: 100%
  :align: center
  :figwidth: 98%


**3.** En vous aidant de l'exemple vu au dessus, **calculer les polygones de voronoi qui correspondant √† la couche** ``STATION_METRO_PARIS`` **en utilisant un buffer de 20%**. Il n'est pas n√©cessaire d'ajouter ce r√©sultat interm√©diaire au projet.

En utilisant vos connaissances en SIG, **s√©lectionner puis √©x√©cuter ensuite le g√©otraitement qui vous permet de d√©couper ces polygones de voronoi par la couche obtenue** ``COMMUNE_PARIS`` afin d'obtenir le r√©sultat qui suit.

**Ajouter ce r√©sultat au projet actuel et renommer la couche** : ``VORONOI_METRO_PARIS``.


.. figure:: img/tp8_11.png
  :width: 100%
  :align: center
  :figwidth: 98%


**4.** En utilisant les notions vues dans les TP pr√©c√©dents, **calculer, pour chaque polygone de Voronoi, la moyenne des salaires m√©dians** (champ ``RDEC_MED16``) **des IRIS intersect√©s** (couche ``IRIS_MENAGE_PARIS``).

Pour chaque polygone de Voronoi, cette valeur doit √™tre stock√©e dans le champ ``MOY_RDEC`` (pour *moyenne des revenus d√©clar√©s*) qu'il est n√©cessaire de cr√©er au pr√©alable.

**‚ö†** Attention lors de la r√©alisation de ce calcul : les IRIS qui pr√©sentent la valeur 0 ne doivent pas √™tre pris en compte dans le calcul de la moyenne *(la valeur 0 n'indique pas un salaire m√©dian de 0 mais la non restitution de la valeur de l'indicateur pour l'IRIS concern√© pour des raisons de confidentialit√© des donn√©es)*.

Enfin, **appliquer le style** ``Style_VORONOI_METRO_PARIS.qml`` **√† la couche** ``VORONOI_METRO_PARIS``.


.. figure:: img/tp8_12.png
  :width: 100%
  :align: center
  :figwidth: 98%


**5.** En utilisant des √©l√©ments vus dans les TP pr√©c√©dents, **√©crire le code n√©cessaire √† organiser les couches** afin qu'elles apparaissent dans l'ordre de la liste qui suit :

::

  layer_order = ['STATION_METRO_PARIS', 'VORONOI_METRO_PARIS', 'COMMUNE_PARIS', 'IRIS_MENAGE_PARIS']


.. figure:: img/tp8_13.png
  :width: 100%
  :align: center
  :figwidth: 98%

**6.** √âcrire une fonction Python ``affiche_salaire_station`` qui accepte un argument, le nom d'une station de m√©tro, et qui affiche la valeur calcul√©e √† l'√©tape 4.

Cette fonction doit donc se pr√©senter de la forme suivante :

::

  def affiche_salaire_station(nom_station):
      # le code permettant d'afficher
      # la valeur pour la station 'nom_station'

Par exemple si on l'invoque avec le nom ``PORTE DE PANTIN`` on doit obtenir le r√©sultat suivant :

::

  affiche_salaire_station('PORTE DE PANTIN')
  # "La moyenne des salaires m√©dians autour de la station 'PORTE DE PANTIN' est de 17048.71 euros"


**üöÄ Question bonus üöÄ** Lors de l'√©tape **4** le calcul r√©alis√© n'est pas tr√®s pr√©cis : en effet, tous les IRIS qui intersectent un polygone de Voronoi
sont pris en compte √† √©galit√© alors qu'il serait plus correct de prendre en compte ces valeurs au prorata des surfaces concern√©es lors du calcul de la moyenne.

**R√©p√©ter la logique de la question 4 en mettant en oeuvre la consigne pr√©c√©dente en stockant cette fois le r√©sultat dans un champ appel√©** ``MOY_RDEC_P`` (pour *moyenne des revenus d√©clar√©s au prorata*).


.. rubric:: \
|

..

  **Le script est √† envoyer √† l'adresse** `matthieu.viry@univ-grenoble-alpes.fr <mailo:matthieu.viry@univ-grenoble-alpes.fr>`_.

..

.. rubric:: Footnotes

.. [#f1] APUR (Atelier Parisien d'Urbanisme) - Jeu de donn√©es "RECENSEMENT IRIS MENAGE" : https://opendata.apur.org/datasets/recensement-iris-menage. Donn√©es t√©l√©charg√©es le 08/04/2020.
.. [#f2] INSEE - Jeu de donn√©es" Revenus, pauvret√© et niveau de vie en 2016 (IRIS)"" : https://www.insee.fr/fr/statistiques/4295611. Donn√©es t√©l√©charg√©es le 08/04/2020.
.. [#f3] APUR (Atelier Parisien d'Urbanisme) - Jeu de donn√©es "STATION TRANSPORT" : https://opendata.apur.org/datasets/station-transport. Donn√©es t√©l√©charg√©es le 08/04/2020.
